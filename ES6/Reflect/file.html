<! DOCTYPE html>
<html>
    <head>
        <title>Reflect</title>
    </head>
    <body>
        <h1>Reflect</h1>
        <script type = "text/javascript">
            function log(value){
                console.log(value);
            }
            /*
             1 . 概述
             Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。
             */
            function method_01(){
                function fun_01(){
                    //（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。
                    
                    //（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
                    
                    // 老写法
                    var target = {};
                    var property = 'name';
                    var attributes = {
                        configurable:true,
                        value: "Kine"
                    };
                    try {
                        Object.defineProperty(target, property, attributes);
                        // success
                        console.log('success');
                    } catch (e) {
                        // failure
                        console.log(`failure:${e}`);
                    }
                    
                    // 新写法
                    if (Reflect.defineProperty(target, property, attributes)) {
                        // success
                        console.log('success');
                    } else {
                        // failure
                        console.log('failure');
                    }
                    
                    //（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
                    // 老写法
                    console.log(property in target); // true
                    
                    // 新写法
                    console.log(Reflect.has(target, property)); // true
                    
                    //（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。
                    var proxy = new Proxy(target, {
                          set: function(target, name, value) {
                          var success = Reflect.set(target,name, value);
                          
                          if (success) {
                          console.log('property ' + name + ' on ' + target + ' set to ' + value);
                          }else{
                          console.log('property ' + name + ' on ' + target + ' set to ' + value);
                          console.log('failure');
                          }
                          return success;
                          }
                    });
                    proxy.name = 'Jim';//property name on [object Object] set to Jim
                    console.log(target);
                    //failure

                    //上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。

                    var loggedObj = new Proxy(target, {
                    get(target, name) {
                    console.log('get', target, name);
                    return Reflect.get(target, name);
                    },
                    deleteProperty(target, name) {
                    console.log('delete' + name);
                    return Reflect.deleteProperty(target, name);
                    },
                    has(target, name) {
                    console.log('has' + name);
                    return Reflect.has(target, name);
                    }
                    });
                    loggedObj.name = "jimmy";
                    console.log(loggedObj.name);//get Object {name: undefined} name
                    console.log('name' in loggedObj);//has name true
                    //上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。
                    
                    //有了Reflect对象以后，很多操作会更易读。
                    // 老写法
                    Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1
                    
                    // 新写法
                    Reflect.apply(Math.floor, undefined, [1.75]) // 1
                }
                fun_01();
                /*
                   2. 静态方法
                 */
                function fun_02(){
                    /*
                     Reflect对象一共有13个静态方法。
                     
                         Reflect.apply(target,thisArg,args)
                         Reflect.construct(target,args)
                         Reflect.get(target,name,receiver)
                         Reflect.set(target,name,value,receiver)
                         Reflect.defineProperty(target,name,desc)
                         Reflect.deleteProperty(target,name)
                         Reflect.has(target,name)
                         Reflect.ownKeys(target)
                         Reflect.isExtensible(target)
                         Reflect.preventExtensions(target)
                         Reflect.getOwnPropertyDescriptor(target, name)
                         Reflect.getPrototypeOf(target)
                         Reflect.setPrototypeOf(target, prototype)
                     上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。
                     */
                    
                    /*
                     1 Reflect.get(target, name, receiver)
                     Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。
                     */
                    function fun_01_1(){
                        var myObject = {
                            foo: 1,
                            bar: 2,
                            get baz() {
                                return this.foo + this.bar;
                            },
                        }
                        console.log(Reflect.get(myObject, 'foo')); // 1
                        log(Reflect.get(myObject, 'bar')); // 2
                        log(Reflect.get(myObject, 'baz')); // 3
                        
                        //如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。
                        var myReceiverObject = {
                            foo: 4,
                            bar: 4,
                        };
                        
                        log(Reflect.get(myObject, 'baz', myReceiverObject)); // 8
                        
                        //如果第一个参数不是对象，Reflect.get方法会报错。
                        /*
                         Reflect.get(1, 'foo') // 报错
                         Reflect.get(false, 'foo') // 报错
                         */
                    }
                    fun_01_1();
                    
                    /*
                        2 Reflect.set(target, name, value, receiver) 
                     Reflect.set方法设置target对象的name属性等于value。
                     */
                    function fun_01_2(){
                        var myObject = {
                            foo: 1,
                            set bar(value) {
                                return this.foo = value;
                            },
                        }
                        log(myObject.foo); // 1
                        
                        Reflect.set(myObject, 'foo', 2);
                        log(myObject.foo); // 2
                        
                        Reflect.set(myObject, 'bar', 3)
                        log(myObject.foo); // 3
                        
                        //如果name属性设置了赋值函数，则赋值函数的this绑定receiver。
                        var myObject2 = {
                            foo: 4,
                            set bar(value) {
                                return this.foo = value;
                            },
                        };
                        
                        var myReceiverObject = {
                            foo: 0,
                        };
                        
                        Reflect.set(myObject2, 'bar', 1, myReceiverObject);
                        log(myObject2.foo); // 4
                        log(myReceiverObject.foo) // 1
                        
                        //如果第一个参数不是对象，Reflect.set会报错。
                        /*
                         Reflect.set(1, 'foo', {}) // 报错
                         Reflect.set(false, 'foo', {}) // 报错
                         */
                    }
                    fun_01_2();

                    /*Reflect.has(obj,name)*/
                    function fun_01_03 () {
                      var myObject = {
                        foo:1,
                      };

                      //旧写法
                      log('foo' in myObject);//true

                      //新写法
                      log(Reflect.has(myObject,'foo'));//true
                      //如果第一个参数不是对象，Reflect.has和in运算符都会报错。
                    }
                    fun_01_03();

                    /*
                    Reflect.deleteProperty(obj, name)
                    Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。
                    */
                    function fun_01_04 () {
                      const myObj = {foo:'bar'};

                      //旧写法
                      delete myObj.foo;

                      //新写法
                      Reflect.deleteProperty(myObj,'foo');//true
                    }
                    fun_01_04();

                    /*
                    Reflect.construct(target, args) 
                    Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
                    */
                    function fun_01_05 () {
                      function Greeting (name) {
                        this.name = name;
                      }

                      //new 的写
                      const instance1 = new Greeting('jimmy');

                      //Relect.construct的写法
                      const instance2 = Reflect.construct(Greeting,['jimmy']);
                      log(instance1,instance2);
                    }
                    fun_01_05();

                    /*
                    Reflect.getPrototypeOf(obj)
                    Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
                    */
                    function fun_01_06 () {
                      function FancyThing (name) {  
                        this.name = name;
                      }
                      const myObj = new FancyThing('name');
                      //旧写法
                      log(Object.getPrototypeOf(myObj) === FancyThing.prototype);//true

                      //新写法
                      log(Reflect.getPrototypeOf(myObj) === FancyThing.prototype);//true
                      //Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果第一个参数不是对象（包括null和undefined），Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。
                    }
                    fun_01_06();
                    /*
                    Reflect.setPrototypeOf(obj, newProto)
                    Reflect.setPrototypeOf方法用于设置对象的__proto__属性，对应Object.setPrototypeOf(obj, newProto)。
                    */
                    function fun_01_07 () {
                       function FancyThing (name) {  
                        this.name = name;
                      }

                      const obj = new FancyThing('name');
                      const othObj = new FancyThing('age');
                      log(othObj);
                      log(typeof othObj);
                      //旧写法
                      log(Object.setPrototypeOf(obj,othObj));
                      log(obj);

                      //新写法
                      othObj.gender = 'male';
                      log(othObj);
                      log(Reflect.setPrototypeOf(obj,othObj.prototype));
                      log(othObj);

                      //如果第一个参数不是对象，Reflect.setPrototypeOf和Object.setPrototypeOf都会报错。
                    }
                    fun_01_07();

                }
                fun_02();
            }
            method_01();
        </script>
    </body>
</html>
