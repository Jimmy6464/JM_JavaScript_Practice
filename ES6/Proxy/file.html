<!DOCTYPE html>
<html>
	<head>
		<title>Proxy</title>
	</head>
	<body>
		<h1>Proxy</h1>
		<script type="text/javascript">
			//1 .概述
			function method_01 () {
				/*
				Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

				Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。
				*/
				var obj = new Proxy({},{
					get:function  (target,key,receiver) {
						console.log(`getting ${key}!`);
						return Reflect.get(target,key, receiver);
					},
					set: function  (target,key,value,receiver) {
						console.log(`setting ${key}!`);
						return Reflect.set(target,key,value,receiver);
					}
				});
				console.log(obj);
				//上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果
				obj.count = 1;//setting count
				++obj.count;
				//getting count!
				//settingcount!
				console.log(obj.count);//getting count!
				//2
				//上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义

				//ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。
				// var proxy = new Proxy(target,handler);
				//Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

				//下面是另一个拦截读取属性行为的例子
				var proxy = new Proxy({},{
					get:function (target,property) {
						console.log(target,property);
						return 35;
					}
				});
				console.log(proxy.time);//Object {} "time" //35
				console.log(proxy.name);//Object {} "name" //35
				console.log(proxy.title);//Object {} "title" //35

				//上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。

				//注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。

				//如果handler没有设置任何拦截，那就等同于直接通向原对象。
				var target = {};
				var handler = {
					set:function (target,key,value) {
						console.log(`This is ${key}`);
						
						return Reflect.set(target,key,value);
					}
				};
				var proxy2 = new Proxy(target,handler);
				proxy2.a = 'b';//This is a
				console.log(target.a);//b

				//一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用
				var object = {proxy:new Proxy(target,{
					get:function (target,key,value) {
						console.log(key,value);
						return value*2;
					},
					set:function (target,key,value) {
						console.log(key,value);
						return Reflect.set(target,key,value);
					}
				})};
				object.length = 3;
				console.log(object.length);//3
				console.log(object);//Object {proxy: Proxy, length: 3}
				object.proxy.time = 3;//time 3
				console.log(target.time);//3


				//Proxy 实例也可以作为其他对象的原型对象。
				var proxy3 = new Proxy({},{
					get:function(target,property) {
						return 35;
					}
				});
				let obj2 = Object.create(proxy);
				console.log(obj2.time);
				//上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截

				//同一个拦截器函数，可以设置拦截多个操作。
				var handler1 = {
					get:function  (target,name) {
						if (name === 'property') {
							return Object.property;
						}
						return 'Hello, ' + name;
					},

					apply:function (target,thisBinding,args) {
						return args[0];
					},

					construct:function  (target,args) {
						return	{value:args[1]};
					}
				};

				var fproxy = new Proxy(function  (x,y) {
					return x+y;
				},handler1);
				console.log(fproxy);//anonymous()
				console.log(fproxy(1,2));//1
				console.log(new fproxy(1,2));//Object{value:2};
				console.log(fproxy.property === Object.property);//true
				console.log(fproxy.foo);//Hello, foo
				//下面是 Proxy 支持的拦截操作一览。

				// 对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。
				/*
				（1）get(target, propKey, receiver)

				拦截对象属性的读取，比如proxy.foo和proxy['foo']。

				最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。

				（2）set(target, propKey, value, receiver)

				拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。

				（3）has(target, propKey)

				拦截propKey in proxy的操作，返回一个布尔值。

				（4）deleteProperty(target, propKey)

				拦截delete proxy[propKey]的操作，返回一个布尔值。

				（5）ownKeys(target)

				拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。

				（6）getOwnPropertyDescriptor(target, propKey)

				拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。

				（7）defineProperty(target, propKey, propDesc)

				拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。

				（8）preventExtensions(target)

				拦截Object.preventExtensions(proxy)，返回一个布尔值。

				（9）getPrototypeOf(target)

				拦截Object.getPrototypeOf(proxy)，返回一个对象。

				（10）isExtensible(target)

				拦截Object.isExtensible(proxy)，返回一个布尔值。

				（11）setPrototypeOf(target, proto)

				拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。

				如果目标对象是函数，那么还有两种额外操作可以拦截。

				（12）apply(target, object, args)

				拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。

				（13）construct(target, args)

				拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。

				Proxy 实例的方法
				*/
			}
			method_01();
			/*
			2. Proxy 实例的方法
			*/
			function method_02 () {
				/*
				get()
				get方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。
				*/
				function fun_01 () {
					var person = {
						name:'Jimmy'
					};
					var proxy = new Proxy(person,{
						get:function  (target,property) {
							if (property in target) {
								return target[property];
							}else{
								throw new ReferenceError("Property \""+property+"\" does not exist.");
							}
						}
					});
					console.log(proxy.name);
					// console.log(proxy.age);//Uncaught ReferenceError: Property "age" does not exist.

					//上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。

					//get方法可以继承。
					let proto = new Proxy({},{
						get(target,propertyKey,receiver){
							console.log('GET'+propertyKey);
							return target[propertyKey];
						}
					});
					let obj = Object.create(proto);
					console.log(obj.xxx);//GETxxx undefined
					//上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。

					//下面的例子使用get拦截，实现数组读取负数的索引。
					function createArray(...elements) {
						let handler2 = {
							get(target,propKey,receiver){
								let index = Number(propKey);
								if (index<0) {
									propKey = String(target.length+index);
									console.log('key is ',propKey);
								}
								return Reflect.get(target,propKey,receiver);
							}
						}

						let target = [];
						target.push(...elements);
						return new Proxy(target,handler2);
					}
					let arr = createArray('a','b','c');
					console.log(arr[-1]);//key is 2 , c
					console.log(arr);//Proxy {0: "a", 1: "b", 2: "c", length: 3}
					//利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。

					var pipe = (function () {

						var pipe;

						return function (value) {

						pipe = [];

						return new Proxy({}, {

						get: function (pipeObject, fnName, receiver) {

						if (fnName == "get") {

						return pipe.reduce(function (val, fn) {
							console.log(fn,val);
						return val;

						}, value);

						}

						pipe.push(window[fnName]);

						return receiver;

						}

						});

						}

						}());

					var double = n => n * 2;
					var pow    = n => n * n;
					var reverseInt = n => n.toString().split("").reverse().join("") | 0;

					console.log(pipe(3).double.pow.reverseInt.get); // 63,有问题

					//下面的例子则是利用get拦截，实现一个生成各种DOM节点的通用函数dom。
					const dom = new Proxy({},{
						get(target,property){
							return function  (attrs ={},...children) {
								const el = document.createElement(property);
								for(let prop of Object.keys(attrs)){
									el.setAttribute(prop,attrs[prop]);
								}
								for(let child of children){
									if (typeof child === 'string') {
										child = document.createTextNode(child);
									}
									el.appendChild(child);
								}
								return el;
							}
						}
					});
					const el = dom.div({},
					  'Hello, my name is ',
					  dom.a({href: 'http://www.baidu.com'}, 'Mark'),
					  '. I like:',
					  dom.ul({},
					    dom.li({}, 'The web'),
					    dom.li({}, 'Food'),
					    dom.li({}, '…actually that\'s it')
					  )
					);

					document.body.appendChild(el);

					//如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错。
					/*
					const target = Object.defineProperties({}, {
					  foo: {
					    value: 123,
					    writable: false,
					    configurable: false
					  },
					});

					const handler = {
					  get(target, propKey) {
					    return 'abc';
					  }
					};

					const proxy = new Proxy(target, handler);

					proxy.foo
					// TypeError: Invariant check failed
					*/
				}
				fun_01();
				/*
				set()
				set方法用来拦截某个属性的赋值操作。
				*/
				function fun_02 () {
					let validator = {
						set:function  (obj,prop,value) {
							if (prop === 'age') {
								if (!Number.isInteger(value)) {
									throw new TypeError('The age is not an integer');
								};
								if (value > 200) {
									throw new RangeError('The age seems invalid');
								}

							};

							// 对于age以外的属性，直接保存
						    obj[prop] = value;
						}

					}

					let person2 = new Proxy({},validator);
					person2.age = 100;
					console.log(person2.age);
					person2.age = 'jim';
					person2.age = 300;
					console.log(person2.age);
					// 上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。

					//有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。
					var handler = {
					  get (target, key) {
					    invariant(key, 'get');
					    return target[key];
					  },
					  set (target, key, value) {
					    invariant(key, 'set');
					    target[key] = value;
					    return true;
					  }
					};
					function invariant (key, action) {
					  if (key[0] === '_') {
					    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
					  }
					}
					var target = {};
					var proxy = new Proxy(target, handler);
					proxy._prop
					// Error: Invalid attempt to get private "_prop" property
					proxy._prop = 'c'
					// Error: Invalid attempt to set private "_prop" property
				}
			}
			method_02();
		</script>
	</body>
</html>