<!DOCTYPE html>
<html>
<head>
	<title>正则的扩展</title>
	<meta charset="utf-8">
</head>
<body>
	<script type="text/javascript">
		/*
		RegExp构造函数 
		*/
		function fun1() {
			//在ES5中，RegExp构造函数的参数有两种情况。
		//第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。
		var regex1 = new RegExp('xyz', 'i');
		// 等价于
		var regex2 = /xyz/i;

		//第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。
		var regex1 = new RegExp(/xyz/i);
		// 等价于
		var regex2 = /xyz/i;

		}

		/*
			字符串的正则方法 
			字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。

			ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。

			String.prototype.match 调用 RegExp.prototype[Symbol.match]
			String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
			String.prototype.search 调用 RegExp.prototype[Symbol.search]
			String.prototype.split 调用 RegExp.prototype[Symbol.split]
		*/

		/*
			u修饰符 :，含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。
		*/
		function fun2() {
			/^\uD83D/u.test('\uD83D\uDC2A');
			// false
			/^\uD83D/.test('\uD83D\uDC2A');
			// true

			//（1）点字符
			//点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。
			var s = '𠮷';

			/^.$/.test(s); // false
			/^.$/u.test(s); // true
			//上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。

			//（2）Unicode字符表示法
			/\u{61}/.test('a'); // false
			/\u{61}/u.test('a'); // true
			/\u{20BB7}/u.test('𠮷'); // true

			//（3）量词
			/a{2}/.test('aa'); // true
			/a{2}/u.test('aa'); // true
			/𠮷{2}/.test('𠮷𠮷'); // false
			/𠮷{2}/u.test('𠮷𠮷'); // true

			/^\u{3}$/.test('uuu'); // true
			//上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。

			//4）预定义模式
			/^\S$/.test('𠮷'); // false
			/^\S$/u.test('𠮷'); // true
			//上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。

			function codePointLength(text) {
				var result = text.match(/[\s\S]/gu);
				return result ? result.length : 0;
			}
			var str = '𠮷';
			console.log(str.length);//2
			console.log(codePointLength(str));//1

			//（5）i修饰符
			//有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。
			/[a-z]/i.test('\u212A') // false
			/[a-z]/iu.test('\u212A') // true
			//上面代码中，不加u修饰符，就无法识别非规范的K字符。
		}
		fun2();
	</script>
</body>
</html>