<!DOCTYPE html>
<html>
	<head></head>
	<body>
		<script type="text/javascript">
			/*
			函数参数的默认值
			*/
			//在ES6之前，不能直接为函数的参数指定默认值
			function log (x,y) {
				y = y||'world';
				console.log(x,y);
			}
			log('hello');//hello world
			log('Hello','China');//Hello China
			log('Hello','');//Hello world
			//。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。
			//change exp:
			/*
			if (typeof y === 'undefined') {
			  y = 'World';
			}
			*/
			//ES6 
			function log2 (x,y='World') {
				console.log(x,y);
			}
			log('Hello'); // Hello World
			log('Hello', 'China'); // Hello China
			log('Hello', ''); // Hello

			function Point (x = 0,y = 0) {
				this.x = x;
				this.y = y;
			}
			var p = new Point();
			console.log(p);//Point {x: 0, y: 0}
			p.x = 10;
			console.log(p);//Point {x: 10, y: 0}
			//参数变量是默认声明的，所以不能用let或const再次声明。

			/*
				与解构赋值默认值结合使用
			*/
			function fun1 () {
				function foo ({x,y = 5}) {
					console.log(x,y);
				}
				foo({});//undefined 5
				foo({x:1});//1 5
				foo({x:1,y:6});//1 6
				/*foo(); TypeError: Cannot read property 'x' of undefined*/

				//上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。

				function fetch (url,{body = '',method = 'GET',headers = {}}) {
					console.log(method);
				}

				fetch('http://baidu.com',{});//GET
				//fetch('http://baidu.com');//Uncaught TypeError: Cannot match against 'undefined' or 'null'
				//上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。

				//上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。
				function fetch1 (url,{method = 'GET'} = {}) {
					console.log(method);
				}
				fetch1('http://baidu.com');//GET
				//上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。


				//区分以下两种写法

				//写法一
				function m1 ({x = 0,y = 0} = {}) {
					console.log(x,y);
				}

				//写法二
				function m2 ({x,y}={x:0,y:0}) {
					console.log(x,y);
				}

				//函数没参数的情况
				m1();//0 0
				m2();//0 0

				//x和y都有值的情况
				m1({x:3,y:8});//3,8
				m2({x:3,y:8});//3,8

				// x有值，y无值的情况
				m1({x: 3}); // [3, 0]
				m2({x: 3}); // [3, undefined]

				// x和y都无值的情况
				m1({}); // [0, 0];
				m2({}); // [undefined, undefined]

				m1({z: 3}); // [0, 0]
				m2({z: 3}); // [undefined, undefined]

				/*
				函数参数默认值位置
				通常情况下，定义了默认值的参数，应该是函数的尾参数
				*/
				//传入undefined，将触发该参数等于默认值，null则没有这个效果。
				function foo1(x = 5, y = 6) {
				  console.log(x, y);
				}

				foo1(undefined, null);
				// 5 null

				/*
				函数的length属性 
				*/
				/*指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。*/
				(function (a) {}).length; // 1
				(function (a = 5) {}).length; // 0
				(function (a, b, c = 5) {}).length; // 2
				/*
				上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了3个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。

				这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性。
				*/
				(function(...args) {}).length; // 0
				//如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
				(function (a = 0, b, c) {}).length; // 0
				(function (a, b = 1, c) {}).length; // 1

				/*
				作用域
				先是当前函数的作用域，然后才是全局作用域。
				*/
				var x = 1;

				function f(x, y = x) {
				  console.log(y);
				}

				f(2); // 2

				//如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。
				let x1 = 1;

				function f2(y = x1) {
				  let x1 = 2;
				  console.log(y);
				}

				f2() // 1

				//
				let tmp = 'outer';

				function bar(func = x => tmp) {//tmp 变量必须先声明否则报错tmp is undefined
				  let tmp = 'inner';
				  console.log(func()); // outer
				}
				bar();
				//上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。

				//
				var x = 1;
				function foo3(x, y = function() { x = 2; }) {
				  var x = 3;
				  y();
				  console.log(x);
				}

				foo3() // 3
				/*上面代码中，函数foo3的参数y的默认值是一个匿名函数。函数foo3调用时，它的参数x的值为undefined，所以y函数内部的x一开始是undefined，后来被重新赋值2。但是，函数foo3内部重新声明了一个x，值为3，这两个x是不一样的，互相不产生影响，因此最后输出3*/

				//应用
				//利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。
				function throwIfMissing () {
					throw new Error('Missing parameter');
				}
				function check (mustBeProvided = throwIfMissing()) {
					return mustBeProvided;
				}
				console.log(check());
			}
			fun1();
			

		</script>
	</body>
</html>