<!DOCTYPE html>
<html>
<head>
	<title>对象的扩展</title>
</head>
<body>
	<script type="text/javascript">
		/*
		属性的简洁表示法 
		*/
		function fun1() {
			//ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
			var foo = 'bar';
			var baz = {foo};
			console.log(baz);//{foo: "bar"}
			//the same as
			console.log({foo:foo});
			//上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。

			//面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。
			function f(x,y) {
				return {x,y};
			}
			//the same as
			function f1(x,y) {
				return {x:x,y:y};
			}
			console.log(f(1,2));//{x: 1, y: 2}
			console.log(f1(1,2));//{x: 1, y: 2}

			//除了属性简写，方法也可以简写。
			var o ={
				method(){
					return 'Hello!';
				}
			}

			//the same as
			var o1 = {
				method:function () {
					return "Hello!";
				}
			}
			console.log(o.method());//Hello!
			console.log(o1.method());//Hello!

			//example
			var birth = '2000/09/01';
			var person = {
				name:'King',
				//the same as : birth:birth
				birth,

				hello(){console.log('my name is ',this.name,' and I was born on ',this.birth)},
				eat:()=>{
					console.log(' is eating')}
			}
			person.hello();//my name is  King  and I was born on  2000/09/01
			person.eat();// is eating

			//这种写法用于函数的返回值，将会非常方便。
			function getPoint() {
			  var x = 1;
			  var y = 10;
			  return {x, y};
			}

			getPoint()
			// {x:1, y:10}

			//CommonJS模块输出变量，就非常合适使用简洁写法。
			var ms = {};
			function getItem(key) {
				 return key in ms ? ms[key] : null;
			}
			function setItem(key,value) {
				ms[key] = value;
			}
			function clear() {
				ms = {};
			}
			// module.exports = {getItem,setItem,clear};
			//the same as
			// module.exports = {
			// 	  getItem: getItem,
			// 	  setItem: setItem,
			// 	  clear: clear
			// };
			// var dict = module.exports.setItem('name','jim');
			// console.log(dict);

			//属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。


			var cart = {
			  _wheels: 4,

			  get wheels () {
			    return this._wheels;
			  },

			  set wheels (value) {
			    if (value < this._wheels) {
			      throw new Error('数值太小了！');
			    }
			    this._wheels = value;
			  }
			}

			//注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。
			var obj = {
			  class () {}
			};

			// 等同于

			var obj = {
			  'class': function() {}
			};
			//上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。

			// 如果某个方法的值是一个Generator函数，前面需要加上星号。
			var obj = {
			  * m(){
			    yield 'hello world';//在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。
			  }
			};
			obj.m();
		}
		fun1();

		/*属性名表达式 */
		function fun2() {
			//JavaScript语言定义对象的属性，有两种方法
			var obj = new Object();
			console.log(obj);//object
			// 方法一
			obj.foo = true;

			// 方法二
			obj['a' + 'bc'] = 123;
			//上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。
			console.log(obj,obj.foo,obj.abc);//{foo: true, abc: 123} true 123
			//但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。
			//the same as
			var obj1 = {
			  foo: true,
			  abc: 123
			};
			console.log(obj1);// {foo: true, abc: 123}

			//ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内
			let propKey = 'name';
			let obj2 = {
				[propKey]:'jimmy',
				['a'+'bc']:'nothing'
			};
			console.log(obj2);//{name: "jimmy", abc: "nothing"}

			//下面是另一个例子。
			var lastWord = 'last word';

			var a = {
			  'first word': 'hello',
			  [lastWord]: 'world'
			};

			a['first word'] // "hello"
			a[lastWord] // "world"
			a['last word'] // "world"

			//表达式还可以用于定义方法名。
			let obj3 = {
				['me'+'thod']:function(){
					console.log('print');
				}
			}
			obj3.method();//print

			//注意，属性名表达式与简洁表示法，不能同时使用，会报错。
			/*
			// 报错
			var foo = 'bar';
			var bar = 'abc';
			var baz = { [foo] };

			// 正确
			var foo = 'bar';
			var baz = { [foo]: 'abc'};
			*/
			//注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。
			const keyA = {a: 1};
			const keyB = {b: 2};

			const myObject = {
			  [keyA]: 'valueA',
			  [keyB]: 'valueB'
			};

			console.log(myObject); // Object {[object Object]: "valueB"}
			//上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。
		}
		fun2();
	</script>
</body>
</html>