<!DOCTYPE html>
<html>
<head>
	<title>对象的扩展</title>
</head>
<body>
	<script type="text/javascript">
		/*
		属性的简洁表示法 
		*/
		function fun1() {
			//ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
			var foo = 'bar';
			var baz = {foo};
			console.log(baz);//{foo: "bar"}
			//the same as
			console.log({foo:foo});
			//上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。

			//面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。
			function f(x,y) {
				return {x,y};
			}
			//the same as
			function f1(x,y) {
				return {x:x,y:y};
			}
			console.log(f(1,2));//{x: 1, y: 2}
			console.log(f1(1,2));//{x: 1, y: 2}

			//除了属性简写，方法也可以简写。
			var o ={
				method(){
					return 'Hello!';
				}
			}

			//the same as
			var o1 = {
				method:function () {
					return "Hello!";
				}
			}
			console.log(o.method());//Hello!
			console.log(o1.method());//Hello!

			//example
			var birth = '2000/09/01';
			var person = {
				name:'King',
				//the same as : birth:birth
				birth,

				hello(){console.log('my name is ',this.name,' and I was born on ',this.birth)},
				eat:()=>{
					console.log(' is eating')}
			}
			person.hello();//my name is  King  and I was born on  2000/09/01
			person.eat();// is eating

			//这种写法用于函数的返回值，将会非常方便。
			function getPoint() {
			  var x = 1;
			  var y = 10;
			  return {x, y};
			}

			getPoint()
			// {x:1, y:10}

			//CommonJS模块输出变量，就非常合适使用简洁写法。
			var ms = {};
			function getItem(key) {
				 return key in ms ? ms[key] : null;
			}
			function setItem(key,value) {
				ms[key] = value;
			}
			function clear() {
				ms = {};
			}
			// module.exports = {getItem,setItem,clear};
			//the same as
			// module.exports = {
			// 	  getItem: getItem,
			// 	  setItem: setItem,
			// 	  clear: clear
			// };
			// var dict = module.exports.setItem('name','jim');
			// console.log(dict);

			//属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。


			var cart = {
			  _wheels: 4,

			  get wheels () {
			    return this._wheels;
			  },

			  set wheels (value) {
			    if (value < this._wheels) {
			      throw new Error('数值太小了！');
			    }
			    this._wheels = value;
			  }
			}

			//注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。
			var obj = {
			  class () {}
			};

			// 等同于

			var obj = {
			  'class': function() {}
			};
			//上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。

			// 如果某个方法的值是一个Generator函数，前面需要加上星号。
			var obj = {
			  * m(){
			    yield 'hello world';//在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。
			  }
			};
			obj.m();
		}
		fun1();

		/*属性名表达式 */
		function fun2() {
			//JavaScript语言定义对象的属性，有两种方法
			var obj = new Object();
			console.log(obj);//object
			// 方法一
			obj.foo = true;

			// 方法二
			obj['a' + 'bc'] = 123;
			//上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。
			console.log(obj,obj.foo,obj.abc);//{foo: true, abc: 123} true 123
			//但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。
			//the same as
			var obj1 = {
			  foo: true,
			  abc: 123
			};
			console.log(obj1);// {foo: true, abc: 123}

			//ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内
			let propKey = 'name';
			let obj2 = {
				[propKey]:'jimmy',
				['a'+'bc']:'nothing'
			};
			console.log(obj2);//{name: "jimmy", abc: "nothing"}

			//下面是另一个例子。
			var lastWord = 'last word';

			var a = {
			  'first word': 'hello',
			  [lastWord]: 'world'
			};

			a['first word'] // "hello"
			a[lastWord] // "world"
			a['last word'] // "world"

			//表达式还可以用于定义方法名。
			let obj3 = {
				['me'+'thod']:function(){
					console.log('print');
				}
			}
			obj3.method();//print

			//注意，属性名表达式与简洁表示法，不能同时使用，会报错。
			/*
			// 报错
			var foo = 'bar';
			var bar = 'abc';
			var baz = { [foo] };

			// 正确
			var foo = 'bar';
			var baz = { [foo]: 'abc'};
			*/
			//注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。
			const keyA = {a: 1};
			const keyB = {b: 2};

			const myObject = {
			  [keyA]: 'valueA',
			  [keyB]: 'valueB'
			};

			console.log(myObject); // Object {[object Object]: "valueB"}
			//上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。
		}
		fun2();
		/*方法的 name 属性 */
		function fun3() {
			//函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
			var person = {
			  sayName() {
			    console.log(this.name);
			  },
			  get firstName() {
			    return "Nicholas";
			  }
			};
			console.log(person.sayName.name);   // "sayName"
			console.log(person.firstName.name); // undefined
			//上面代码中，方法的name属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上get。如果是存值函数，方法名的前面会加上set。
			// 有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”
			console.log((new Function()).name); // "anonymous"

			var doSomething = function() {
			  // ...
			};
			console.log(doSomething.bind().name); // "bound doSomething"

			//如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。
			const key1 = Symbol('description');
			const key2 = Symbol();
			let obj = {
			  [key1]() {},
			  [key2]() {},
			};
			console.log(obj[key1].name); // "[description]"
			console.log(obj[key2].name); // ""
			//上面代码中，key1对应的Symbol值有描述，key2没有。
		}
		fun3();
		/*
		Object.is() 
		*/
		function fun4() {
			/*
			ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。

			ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
			*/
			console.log(Object.is('foo', 'foo'));
			// true
			console.log(Object.is({}, {}));
			// false

			//不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
			console.log(+0 === -0); //true
			console.log(NaN === NaN); // false

			console.log(Object.is(+0, -0)); // false
			console.log(Object.is(NaN, NaN)); // true

			//ES5可以通过下面的代码，部署Object.is。
			Object.defineProperty(Object, 'is', {
			  value: function(x, y) {
			    if (x === y) {
			      // 针对+0 不等于 -0的情况
			      return x !== 0 || 1 / x === 1 / y;
			    }
			    // 针对NaN的情况
			    return x !== x && y !== y;
			  },
			  configurable: true,
			  enumerable: false,
			  writable: true
			});
		}
		fun4();

		/*
		Object.assign() 
		*/
		function fun5() {
			//基本用法 
			//Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
			var target = { a: 1 };

			var source1 = { b: 2 };
			var source2 = { c: 3 };
			var source3 = { d: 4 };
			Object.assign(target, source1, source2, source3);
			console.log(target); // {a: 1, b: 2, c: 3, d: 4}
			//Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。

			//注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
			var target2 = { a: 1, b: 1 };

			var source4 = { b: 2, c: 2 };
			var source5 = { c: 3 };

			Object.assign(target2, source4, source5);
			console.log(target2); // {a:1, b:2, c:3}

			//如果只有一个参数，Object.assign会直接返回该参数。
			var obj = {a: 1};
			console.log(Object.assign(obj) === obj); // true
			// 如果该参数不是对象，则会先转成对象，然后返回。
			console.log(typeof Object.assign(2) );// "object"

			//由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。

			//如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。
			let obj1 = {a: 1};
			console.log(Object.assign(obj1, undefined) === obj1); // true
			console.log(Object.assign(obj1, null) === obj1 );// true

			// 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
			var v1 = 'abc';
			var v2 = true;
			var v3 = 10;

			var obj2 = Object.assign({}, v1, v2, v3);
			console.log(obj2); //  {0: "a", 1: "b", 2: "c"}
			//上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。
			console.log(Object(true)); // Boolean {[[PrimitiveValue]]: true}
			console.log(Object(10));  //  Number {[[PrimitiveValue]]: 10}
			console.log(Object('abc')); //String {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
			//上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。

			//Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
			var obj3 = Object.assign({b: 'c'},
			  Object.defineProperty({}, 'invisible', {
			    enumerable: false,//if true,it will output " {b: "c", invisible: "hello"}"
			    value: 'hello'
			  })
			)
			// { b: 'c' }
			console.log(obj3);//Object {b: "c"}
			//上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。

			//属性名为Symbol值的属性，也会被Object.assign拷贝。
			var obj4 = Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' });
			console.log(obj4);// { a: 'b', Symbol(c): 'd' }

			/*
			注意点 
			Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
			*/
			var obj5 = {a: {b: 1}};
			var obj6 = Object.assign({}, obj5);

			obj5.a.b = 2;
			console.log(obj6.a.b); // 2
			obj6.a.b = 3;// the same as ,obj5.a.b = 3
			console.log(obj6.a.b, obj5.a.b); // 3 3
			//上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面

			//对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。
			var target = { a: { b: 'c', d: 'e' } };
			var source = { a: { b: 'hello' } };
			console.log(Object.assign(target, source));
			// { a: { b: 'hello' } }
			//上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: 'hello', d: 'e' } }的结果。这通常不是开发者想要的，需要特别小心。

			//有一些函数库提供Object.assign的定制版本（比如Lodash的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。

			//注意，Object.assign可以用来处理数组，但是会把数组视为对象。
			console.log(Object.assign([1, 2, 3], [4, 5]));//[4, 5, 3]
			//上面代码中，Object.assign把数组视为属性名为0、1、2的对象，因此目标数组的0号属性4覆盖了原数组的0号属性1。

			/*
			常见用途 
			*/

			//（1）为对象添加属性
			class Point {
			  constructor(x, y) {
			    Object.assign(this, {x, y});
			  }
			}
			var class1 = new Point();
			class1.constructor.x = 0;
			console.log(class1.constructor.x);//0;

			//(2）为对象添加方法
			Object.assign(class1.constructor, {
			  someMethod(arg1, arg2) {
			    console.log(arg1,arg2);
			  },
			  anotherMethod() {
			  	console.log('you are so handsome');
			  }
			});
			class1.constructor.someMethod("jimmy","bb");//jimmy bb
			class1.constructor.anotherMethod();//you are so handsome
			// 等同于下面的写法
			class1.constructor.someMethod = function (arg1, arg2) {
			  console.log(arg1,"+",arg2);
			};
			class1.constructor.anotherMethod = function () {
			  console.log('you are so handsome');
			};
			class1.constructor.someMethod("jimmy","bb");//jimmy + bb
			class1.constructor.anotherMethod();//you are so handsome
			//上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到class1.constructor之中。

			//（3）克隆对象
			function clone(origin) {
			  return Object.assign({}, origin);
			}
			// 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。

			// 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。
			function clone2(origin) {
			  let originProto = Object.getPrototypeOf(origin);
			  return Object.assign(Object.create(originProto), origin);
			}

			//（4）合并多个对象
			const merge = (target, ...sources) => Object.assign(target, ...sources);
			//如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。
			const merge2 = (...sources) => Object.assign({}, ...sources);

			//（5）为属性指定默认值
			const DEFAULTS = {
			  logLevel: 0,
			  outputFormat: 'html'
			};

			function processContent(options) {
			  options = Object.assign({}, DEFAULTS, options);
			}

			/*
			上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。

			注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致DEFAULTS对象的该属性不起作用。
			*/
		}
		fun5();
		/*
		属性的可枚举性
		*/
		function fun6() {
			//对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
			var foo = {foo:"jimmy"};
			console.log(Object.getOwnPropertyDescriptor(foo,'foo'));//获取该属性的描述对象。


			console.log(Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable);// false

			console.log(Object.getOwnPropertyDescriptor([], 'length').enumerable);// false
			//上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。

			//ES6规定，所有Class的原型的方法都是不可枚举的
			console.log(Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable);// false

		}
		fun6();
	</script>
</body>
</html>