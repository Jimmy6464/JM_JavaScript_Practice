<!DOCTYPE html>
<html>
<head>
	<title>Symbol</title>
</head>
<body>
	<h1>Symbol</h1>
	<script type="text/javascript">
		//Symbol
		//ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

		/*
			1. 作为属性名的Symbol 
		*/
		function fun1() {
			//由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
			var mySymbol = Symbol();

			// 第一种写法
			var a = {};
			a[mySymbol] = 'Hello!';

			// 第二种写法
			var a = {
			  [mySymbol]: 'Hello!'
			};

			// 第三种写法
			var a = {};
			Object.defineProperty(a, mySymbol, { value: 'Hello!' });

			// 以上写法都得到同样结果
			console.log(a[mySymbol]); // "Hello!"

			//注意，Symbol值作为对象属性名时，不能用点运算符。
			var b = {};
			var s1 = Symbol();
			b.s1 = 'Hello!';
			console.log(b[s1]); // undefined
			console.log(b['s1']); // "Hello!"
			//上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol值。
			
			
			//同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。
			var s = Symbol();
			var obj = {
				[s](arg){
					console.log(arg);
				}
			}
			obj[s]('hi');//'hi'

			//Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。
			var obj1 = {lev:"hi",me:function (arg){
				console.log(arg,this.lev);
			} };
			obj1.me('jim');
			const Color_Red = Symbol();
			const Color_Green = Symbol();

			function getComplement(color) {
				switch(color){
					case Color_Red:
					return Color_Green;
					case Color_Green:
					return Color_Red;
					default:
						throw new Error("undefined color");
				}
			}
			

		}
		fun1();
	</script>
</body>
</html>