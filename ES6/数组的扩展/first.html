<!DOCTYPE html>
<html>
<head>
	<title>数组的扩展</title>
</head>
<body>
	<h1>数组的扩展</h1>
	<p>1,Array.from()</p>
	<p><span>2,Array.from()</span></p>
	<script type="text/javascript">
		//1.Array.from() 
		//Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。
		// 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。
		function fun1() {
			let arrayLike ={
				'0':'a',
				'1':'b',
				'2':'c',
				length:3
			};
			//es5写法
			var arr1 = [].slice.call(arrayLike);//['a','b','c']
			console.log('es5写法 : '+arr1);

			//es6写法
			var arr2 = Array.from(arrayLike);//['a','b','c']
			console.log('es6写法 : '+arr2);

			// NodeList对象
			let ps = document.querySelectorAll('p');
			console.log('arr:'+Array.from(ps));//arr:[object HTMLParagraphElement]
			Array.from(ps).forEach(function(p){
				console.log(p);
			});

			//arguments对象
			function foo(argument) {
				var agrs = Array.from(argument);
			}

			// 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法。

			// 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。
			console.log(Array.from('Jimmy'));//["J", "i", "m", "m", "y"]
			let namesSet = new Set(['a', 'b'])
			Array.from(namesSet) // ['a', 'b']
			//上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。

			//值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。
			// arguments对象
			function foo2() {
			  var args = [...arguments];
			}

			// NodeList对象
			var p1 = [...document.querySelectorAll('p')];
			console.log(p1);//[p, p];

			//对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。
			const toArray = (() =>
			  Array.from ? Array.from : obj => [].slice.call(obj)
			)();

			//Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
			var x = 2;
			Array.from(arrayLike, x => x * x);
			// 等同于
			Array.from(arrayLike).map(x => x * x);

			Array.from([1, 2, 3], (x) => x * x)
			// [1, 4, 9]

			//下面的例子是取出一组DOM节点的文本内容。
			let spans = document.querySelectorAll('span');
			console.log(spans);
			// map()
			let names1 = Array.prototype.map.call(spans, s => s.textContent);
			console.log(names1);
			// Array.from()
			let names2 = Array.from(spans, s => s.textContent)
			console.log(names2);

			//下面的例子将数组中布尔值为false的成员转为0。
			Array.from([1, , 2, , 3], (n) => n || 0);// [1, 0, 2, 0, 3]

			//返回各种数据的类型
			function typesOf () {
			  return Array.from(arguments, value => typeof value)
			}
			console.log(typesOf(null, [], NaN));// ['object', 'object', 'number']

			Array.from({ length: 2 }, () => 'jack');// ['jack', 'jack']
			//上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。

			//Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。
			function countSymbols(string) {
			  return Array.from(string).length;
			}
			console.log(countSymbols('Jackey'));
		}
		fun1();

		/*
		2.Array.of()
		Array.of方法用于将一组值，转换为数组
		*/
		function fun2() {
			Array.of(3, 11, 8); // [3,11,8]
			Array.of(3); // [3]
			Array.of(3).length; // 1
			//这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。
			Array() ;// []
			Array(3) ;// [, , ,]
			Array(3, 11, 8) ;// [3, 11, 8]

			//Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。
			Array.of(); // []
			Array.of(undefined); // [undefined]
			Array.of(1); // [1]
			Array.of(1, 2); // [1, 2]

			// Array.of方法可以用下面的代码模拟实现。
			function ArrayOf(){
			  return [].slice.call(arguments);
			}
		}
		fun2();
		/*
		数组实例的copyWithin() 
		数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
		它接受三个参数。
			target（必需）：从该位置开始替换数据。
			start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
			end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
		*/
		function fun3() {
			/*
			Array.prototype.copyWithin(target, start = 0, end = this.length);
			*/
			// 将3号位复制到0号位
			[1, 2, 3, 4, 5].copyWithin(0, 3, 4);
			// [4, 2, 3, 4, 5]

			// -2相当于3号位，-1相当于4号位
			[1, 2, 3, 4, 5].copyWithin(0, -2, -1);
			// [4, 2, 3, 4, 5]

			// 将3号位复制到0号位
			[].copyWithin.call({length: 5, 3: 1}, 0, 3);
			// {0: 1, 3: 1, length: 5}

			// 将2号位到数组结束，复制到0号位
			var i32a = new Int32Array([1, 2, 3, 4, 5]);
			i32a.copyWithin(0, 2);
			// Int32Array [3, 4, 5, 4, 5]

			// 对于没有部署TypedArray的copyWithin方法的平台
			// 需要采用下面的写法
			[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
			// Int32Array [4, 2, 3, 4, 5]
		}

		/*
		数组实例的find()和findIndex() 
		*/
		function fun4() {
			//数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
			var tmp  = ['1','4','-3','5'].find((n)=> n >2);
			console.log(tmp);//4(符合条件第一个)
			[1, 5, 10, 15].find(function(value, index, arr) {
			  return value > 9;
			}) // 10
			// 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。

			// 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
			[1, 5, 10, 15].findIndex(function(value, index, arr) {
			  return value > 9;
			}) // 2

			//这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。
			// 另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。
			[NaN].indexOf(NaN)
			// -1

			[NaN].findIndex(y => Object.is(NaN, y))
			// 0
			//上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。
		}
		fun4();
	</script>
</body>
</html>
